* Spookfox

Communicate between Firefox and Emacs. Because [[https://nyxt.atlas.engineer/][Nyxt]] is just not there yet.

** Features

1. Save all open tabs as org-mode subtrees.

   I have a habit of opening too many browser tabs open, many of which I don't
   even visit as often. Although the browser would discard the tab to save
   resources, it is still clutter. And too easy to accidentally click on it and
   waste precious CPU/RAM.

   To remedy that, we can save all the browser tabs open in the browser right
   now in an org file. Configure the [[https://orgmode.org/manual/Template-elements.html][target]]:

   #+begin_src elisp
     (setq spookfox-saved-tabs-target '(file+headline "~/org/browser.org" "Open Tabs"))
   #+end_src

   Now you can save all your currently open browser tabs in the configured target.

   #+begin_src elisp
     (spookfox-save-all-tabs)
   #+end_src

   This will open an org capture buffer where you can preview and change the
   tabs as org nodes before saving.

   Note: This will not close open tabs in browser. You can have that pleasure
   yourself.

   *Organize tabs into groups*

   It is possible to create "tab groups" using org-mode tags. Applying a tag on
   a tab node will make it a member of that tab group. Since the org subtree of
   tabs can be organized in any hierarchy, you can use this to apply a tag on
   multiple tabs.

2. Open a saved tab

   Once you have saved the gazillion tabs you had open in your browser, you can
   structure them in the =spookfox-saved-tabs-target= any way you desire, as
   long as the you maintain the integrity of properties spookfox added to
   =:PROPERTIES:= drawer.

   You can use =spookfox-open-tab= to select one of the saved tabs and open it
   in the browser connected via spookfox. It uses Emacs' built-in completion, so
   if you are using something like ivy or helm you might see a completion UI.

   #+begin_src elisp
     (spookfox-open-tab)
   #+end_src

   *Behavior*:

   - If an existing tab is selected
     - If it is already present in browser, it is focused. Else a new tab is
       opened
   - If you enter a string which don't match any existing saved tabs
     - If entered string is a valid http(s) URL, a new tab with this URL is
       opened. Else a search with your configured search engine is performed in
       the new tab.

3. Open a tab group

   You can open a group of tabs using =spookfox-open-tab-group=. It will open
   all the tabs that belong to the group in current browser. If a tab is already
   open, it is not reopened but will be awoken if it is in discarded state
   (browsers do that to save resources).

   #+begin_src elisp
     (spookfox-open-tab-group)
   #+end_src

4. Get active tab

  #+begin_src elisp
  (sf--get-active-tab)
  #+end_src

  #+RESULTS:
  | :id | 97 | :isPinned | :false | :title | permissions - Mozilla | MDN | :url | https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/manifest.json/permissions |

  I use this to quickly capture notes for what I am reading in Firefox. This is
  not an interactive command (i.e you can't call it with =M-x=), because what
  would you want to do that for?

** Architecture
1. *spookfox.el*: Emacs package written in Emacs Lisp
2. *spookfox-addon*: Firefox extension written in Javascript
3. *spookfox-native*: Glue code written in Rust

Firefox extension uses Native Messaging, which require an executable which
accepts input from stdin, and provides its output at stdout. Emacs itself proved
unusable for that purpose. So I've written some glue code which communicates
with the Browser.

*** Components

Spookfox has 3 primary components:

1. <<sn>> : spookfox-native : Glue code written in Rust
2. <<sa>> : spookfox-addon : Firefox addon written in Javascript
3. <<se>> : spookfox-el : Emacs package written in Emacs Lisp
4. <<ss>> : spookfox-socket : A UNIX socket used for IPC b/w [[se]] and [[sn]]

4th is just a file (well socket, but you know what I mean).

*** Control Flows

- [[sa]] starts [[sn]] on browser startup.

  [[sn]] is now a running process to which browser communicates via =stdin= and
  =stdout=. Anything [[sn]] prints become a message [[sa]] receives and tries to
  interpret as a command.

**** Emacs sending commands to Firefox

- [[sn]] spawns a thread which connects to [[ss]] for messages to/from Emacs
- [[se]] connects to [[ss]]
- Emacs receives input from User to execute a command in browser
- [[se]] create a JSON string (referred to as =msg=) and sends it to [[ss]]
- [[sn]] reads =msg= on [[ss]]
- [[sn]] prints the =msg= as-is to stdout, to which [[sa]] is listening
- [[sa]] receives =msg=
  - parses it
  - executes it
  - post a response back to [[sn]]
- [[sn]] receives the response from [[sa]] and passes it to [[ss]]
- [[se]] now has the response (received over [[ss]]) of message it sent to browser
